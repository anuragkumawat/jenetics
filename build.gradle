/*
 * Java Genetic Algorithm Library (@__identifier__@).
 * Copyright (c) @__year__@ Franz Wilhelmstötter
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author:
 *    Franz Wilhelmstötter (franz.wilhelmstoetter@gmx.at)
 */

import java.text.SimpleDateFormat
import java.util.Date
import org.apache.tools.ant.filters.ReplaceTokens

import org.jenetics.gradle.PropertiesLoader
import org.jenetics.gradle.Version
import org.jenetics.gradle.task.ChecksumTask

/**
 * @author <a href="mailto:franz.wilhelmstoetter@gmx.at">Franz Wilhelmstötter</a>
 * @since 1.2
 * @version 1.4 &mdash; <em>$Date$</em>
 */

apply plugin: 'signing'

apply from: "${rootDir}/gradle/commons.gradle"
apply from: "${rootDir}/gradle/packaging.gradle"


new PropertiesLoader(ext).load(file('project.properties'))
new PropertiesLoader(ext).load(file('include.properties'))
rootProject.version = Version.parse(jenetics.version)

ext {
	now = Calendar.getInstance()
	year = now.get(Calendar.YEAR);
	copyrightYear = "2007-${year}".toString()
	identifier = "${rootProject.name}-${version}".toString()
	manualDate = (new SimpleDateFormat("yyyy/MM/dd")).format(now.time)
	manualIdentifier = "${version}---${manualDate}".toString()
	dateformat = new SimpleDateFormat("yyyy-MM-dd HH:mm")
	
	// Define some 'global' path variables.
	exportDir = file("${buildDir}/package/${identifier}")
	exportProjectDir = file("${exportDir}/project")
	exportProjectLibDir = file("${exportProjectDir}/buildSrc/lib")
	exportLibDir = file("${exportDir}/lib")
	exportJavadocDir = file("${exportDir}/javadoc")
	exportReportDir = file("${exportDir}/report")
	exportScriptDir = file("${exportDir}/script")
}

allprojects {
	group = 'org.jenetics'
	version = jenetics.version

	repositories {
		flatDir(dir: "${rootDir}/buildSrc/lib")
		mavenCentral()
	}
}

subprojects { project ->
	if (project.plugins.hasPlugin('java')) {
		sourceCompatibility = javaVersion
		targetCompatibility = javaVersion
	}
}

task wrapper(type: Wrapper) {
	gradleVersion = '1.7'
}

task alljavadoc(type: Javadoc) {
	def jeneticsProjects = subprojects.findAll { project -> 
		project.name.startsWith('org.jeneti') &&
		project.name != 'org.jenetics.doc'
	}
	configure(jeneticsProjects) {
		apply plugin: 'java'
	}
	
	source jeneticsProjects.collect { p ->
		p.sourceSets.main.allJava
	}
	destinationDir = file("${buildDir}/alljavadoc")
	
	// Might need a classpath
	classpath = files(jeneticsProjects.collect { project ->
		project.sourceSets.main.compileClasspath
	})
}

task packaging(overwrite: true) {
	inputs.dir file('.')
	outputs.dir exportDir

	// Create the directory structure.
	doFirst {
		exportDir.mkdirs()
		exportProjectDir.mkdirs()
		exportProjectLibDir.mkdirs()
		exportLibDir.mkdirs()
		exportReportDir.mkdirs()
		exportJavadocDir.mkdirs()
		exportScriptDir.mkdirs()
	}

	doLast  {
		// Copy the files in the base directory.
		copy {
			from('.') {
				include '*'
				exclude 'org.*'
				exclude '.gradle'
				exclude '.hgignore'
				exclude '.hgtags'
				exclude '*.iml'
				exclude '*.ipr'
				exclude '*.iws'
				exclude '.project'
				exclude '.classpath'
				exclude 'build'
			}
			into exportProjectDir
			filter(ReplaceTokens, tokens: [
				__identifier__: identifier,
				__year__: copyrightYear
			])
		}
		copy {
			from('.') {
				include 'gradle/**/*'
			}
			into exportProjectDir
		}
		
		// Copy 'buildSrc' files.
		copy {
			from(project('buildSrc').projectDir) {
				include '*.gradle'
				include 'src/**/*.java'
				include 'src/**/*.gradle'
				include 'src/**/*.xml'
				include 'src/**/*.c'
				include 'src/**/*.cpp'
				include 'src/**/*.h'
				include 'src/**/*.hpp'
			}
			into file("${exportProjectDir}/buildSrc")
			filter(ReplaceTokens, tokens: [
				__identifier__: identifier,
				__year__: copyrightYear
			])
		}
		copy {
			from(project('buildSrc').projectDir) {
				include 'src/**/*.*'
				include 'lib/**/*'
				include 'tool/**/*'
				include 'resources/**/*'
				exclude 'src/**/*.java'
				exclude 'src/**/*.gradle'
				exclude 'src/**/*.xml'
				exclude 'src/**/*.c'
				exclude 'src/**/*.cpp'
				exclude 'src/**/*.h'
				exclude 'src/**/*.hpp'
			}
			into file("${exportProjectDir}/buildSrc")
		}
	}
}

// Create a zip file from the export directory.
task zip(type: Zip) {
	from("build/package/${identifier}") {
		into identifier
	}

	baseName = rootProject.name
	version = jenetics.version

	doLast {
		def zip = file("${identifier}.zip")
		zip.renameTo(new File('build/package', zip.getName()))
	}
}

task sha256(type: ChecksumTask) {
	algorithm = 'SHA-256'
	inputFile = file("build/distributions/${identifier}.zip")
}

task md5(type: ChecksumTask) {
	inputFile = file("build/distributions/${identifier}.zip")
}

zip.finalizedBy([sha256, md5])

signing {
	//gpg --armor --detach-sign jenetics-1.4.0.zip
	//gpg --verify jenetics-1.4.0.zip.asc jenetics-1.4.0.zip
	sign zip
}


